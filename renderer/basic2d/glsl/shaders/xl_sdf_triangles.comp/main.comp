#version 450
#extension GL_GOOGLE_include_directive : enable

#include "XL2dGlslVertexData.h"
#include "XL2dGlslShadowData.h"
#include "XL2dGlslSdfData.h"

layout (local_size_x = 64) in;

#include "XL2dGlslSdfDescriptors.h"

void main() {
	const uint gID = gl_GlobalInvocationID.x;

    if (gID < shadowData.trianglesCount) {
		Sdf2DObjectData triangle;
		triangle.object = gID + shadowData.trianglesFirst;
		triangle.type = 0;

		const Triangle2DIndex idx = TRIANGLE_INDEX_BUFFER[gID];
		const mat4 transform = TRANSFORM_BUFFER[idx.transform].transform;

		triangle.a = ((transform * VERTEX_BUFFER[idx.a]).xy) * shadowData.shadowDensity;
		triangle.b = ((transform * VERTEX_BUFFER[idx.b]).xy) * shadowData.shadowDensity;
		triangle.c = ((transform * VERTEX_BUFFER[idx.c]).xy) * shadowData.shadowDensity;

		triangle.transform = idx.transform;
		triangle.value = idx.value;
		triangle.opacity = idx.opacity;

		triangle.bbMin = min(min(triangle.a, triangle.b), triangle.c) - shadowData.bbOffset.xx;
		triangle.bbMax = max(max(triangle.a, triangle.b), triangle.c) + shadowData.bbOffset.xx;

		ivec2 minCell = ivec2(trunc(triangle.bbMin / vec2(shadowData.gridSize, shadowData.gridSize)));
		ivec2 maxCell = ivec2(floor(triangle.bbMax / vec2(shadowData.gridSize, shadowData.gridSize)));

		for (int i = minCell.x; i <= maxCell.x; ++ i) {
			for (int j = minCell.y; j <= maxCell.y; ++ j) {
				emplaceIntoGrid(i, j, triangle.object);
			}
		}

		OBJECTS_DATA_BUFFER[triangle.object] = triangle;
    }
}
