#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference_uvec2 : require

#include "SPGlslInit.h"
#include "XL2dGlslParticle.h"
#include "XL2dGlslVertexData.h"

layout(buffer_reference) readonly buffer EmitterBuffer;
layout(buffer_reference) readonly buffer EmissionPointsBuffer;
layout(buffer_reference) buffer ParticlesBuffer;
layout(buffer_reference) buffer VerticesBuffer;
layout(buffer_reference) buffer CommandBuffer;

layout (push_constant) uniform PCB {
	ParticleConstantData pcb;
};

layout(std430, buffer_reference, buffer_reference_align = 8) readonly buffer EmitterBuffer {
	ParticleEmitterData data;
};

layout(std430, buffer_reference, buffer_reference_align = 8) readonly buffer EmissionPointsBuffer {
	ParticleEmissionPoints data;
	vec2 points[];
};

layout(std430, buffer_reference, buffer_reference_align = 8) buffer ParticlesBuffer {
	ParticleData particles[];
};

layout(std430, buffer_reference, buffer_reference_align = 8) buffer VerticesBuffer {
	Vertex vertices[];
};

layout(std430, buffer_reference, buffer_reference_align = 8) buffer CommandBuffer {
	ParticleIndirectCommand command;
};

layout(local_size_x = 64) in;

#define brand(particle, bound) (pcg16_boundedrand_r(particle.rng, bound))
#define rand(particle) (pcg16_random_r(particle.rng))
#define frand(particle) (pcg16_random_float_r(particle.rng))
#define vrand(particle) (vec2(frand(particle), frand(particle)))

vec2 getNormalFromAngle(float angle) {
	return vec2(cos(angle), sin(angle));
}

vec2 rotateNormalVec(vec2 n, vec2 dA) {
	return n * dA.x + vec2(-n.y, n.x) * dA.y;
}

void emitParticle(inout ParticleData particle) {
	const ParticleEmitterData emitter = EmitterBuffer(pcb.emitterPointer).data;

	vec2 emissionPoint;
	if (emitter.emissionType == 0) {
		EmissionPointsBuffer points = EmissionPointsBuffer(emitter.emissionData);
		uint index = brand(particle, points.data.count);
		emissionPoint = points.points[index];
	}

	particle.position = emissionPoint;
	particle.sizeNormal = emitter.sizeNormal;
	particle.color = emitter.color;

	particle.fullLifetime = uint(ceil((emitter.lifetime.init + emitter.lifetime.rnd * frand(particle)) / emitter.frameInterval));
	particle.currentLifetime = particle.fullLifetime;

	if ((emitter.flags & (1 << 3)) != 0) {
		particle.framesUntilEmission = uint(ceil((emitter.lifetime.init + emitter.lifetime.rnd) / emitter.frameInterval));
	} else {
		particle.framesUntilEmission = particle.currentLifetime;
	}

	particle.scale = emitter.sizeValue * (emitter.scale.init + emitter.scale.rnd * frand(particle));
	particle.angle = getNormalFromAngle(emitter.angle.init + emitter.angle.rnd * frand(particle));
	particle.normal = getNormalFromAngle(emitter.normal.init + emitter.normal.rnd * frand(particle));

	particle.velocity = emitter.velocity.init + emitter.velocity.rnd * frand(particle);
	particle.linearVelocity = emitter.linearVelocity.init + emitter.linearVelocity.rnd * vrand(particle);

	particle.qAngularVelocity = (getNormalFromAngle(emitter.angularVelocity.init + emitter.angularVelocity.rnd * frand(particle)))
			* emitter.frameInterval;

	particle.orbitalVelocity = emitter.orbitalVelocity.init + emitter.orbitalVelocity.rnd * frand(particle);

	particle.radialVelocity = emitter.radialVelocity.init + emitter.radialVelocity.rnd * frand(particle);

	particle.qAcceleration = (emitter.acceleration.init + emitter.acceleration.rnd * frand(particle))
			* emitter.frameInterval;

	particle.qLinearAcceleration = (emitter.linearAcceleration.init + emitter.linearAcceleration.rnd * vrand(particle))
			* emitter.frameInterval;

	particle.radialAcceleration = emitter.radialAcceleration.init + emitter.radialAcceleration.rnd * frand(particle);
	particle.tangentialAcceleration = emitter.tangentialAcceleration.init + emitter.tangentialAcceleration.rnd * frand(particle);
	particle.hue = emitter.hue.init + emitter.hue.rnd * frand(particle);
}

void simulateParticleFrame(inout ParticleData particle) {
	particle.velocity = particle.velocity + particle.qAcceleration;
	particle.linearVelocity = particle.linearVelocity + particle.qLinearAcceleration;

	vec2 alongNormal = particle.normal * particle.velocity * pcb.dt;
	vec2 linear = particle.linearVelocity * pcb.dt;

	particle.position = particle.position + alongNormal + linear;

	particle.angle = rotateNormalVec(particle.angle, particle.qAngularVelocity);
}

void main() {
	VerticesBuffer vertexBuffer = VerticesBuffer(pcb.outVerticesPointer);
	CommandBuffer commandBuffer = CommandBuffer(pcb.outCommandPointer);
	ParticlesBuffer particleBuffer = ParticlesBuffer(pcb.particlesPointer);

	uint nframes = pcb.nframes;

	ParticleData particle = ParticlesBuffer(pcb.particlesPointer).particles[gl_GlobalInvocationID.x];

	// first - simulate particle
	if (nframes > 0) {
		// lifetime is ended
		if (particle.currentLifetime <= nframes) {
			particle.currentLifetime = 0;
		}

		if (particle.framesUntilEmission < nframes) {
			nframes -= particle.framesUntilEmission;

			// emit new particle, then simulate it
			emitParticle(particle);
		}

		if (particle.currentLifetime != 0) {
			for (uint i = 0; i < nframes; ++ i) {
				simulateParticleFrame(particle);
			}

			particleBuffer.particles[gl_GlobalInvocationID.x] = particle;
		}
	}

	// second - write vertexes for the paticle

	const uint vertexOffset = atomicAdd(commandBuffer.command.vertexCount, 6);

	vec2 bl = rotateNormalVec(-particle.sizeNormal, particle.angle) * particle.scale;
	vec2 tl = rotateNormalVec(vec2(-particle.sizeNormal.x, particle.sizeNormal.y), particle.angle) * particle.scale;
	vec2 tr = rotateNormalVec(particle.sizeNormal, particle.angle) * particle.scale;
	vec2 br = rotateNormalVec(vec2(particle.sizeNormal.x, -particle.sizeNormal.y), particle.angle) * particle.scale;

	const float texLeft = 0.0f;
	const float texRight = 1.0f;
	const float texTop = 0.0f;
	const float texBottom = 1.0f;

	vertexBuffer.vertices[vertexOffset + 0].pos = vec4(particle.position + bl, 0.0, 1.0);
	vertexBuffer.vertices[vertexOffset + 0].tex = vec2(texLeft, texTop);
	vertexBuffer.vertices[vertexOffset + 0].color = particle.color;

	vertexBuffer.vertices[vertexOffset + 1].pos = vec4(particle.position + tl, 0.0, 1.0);
	vertexBuffer.vertices[vertexOffset + 1].tex = vec2(texLeft, texBottom);
	vertexBuffer.vertices[vertexOffset + 1].color = particle.color;

	vertexBuffer.vertices[vertexOffset + 2].pos = vec4(particle.position + br, 0.0, 1.0);
	vertexBuffer.vertices[vertexOffset + 2].tex = vec2(texRight, texTop);
	vertexBuffer.vertices[vertexOffset + 2].color = particle.color;

	vertexBuffer.vertices[vertexOffset + 3].pos = vec4(particle.position + tr, 0.0, 1.0);
	vertexBuffer.vertices[vertexOffset + 3].tex = vec2(texRight, texBottom);
	vertexBuffer.vertices[vertexOffset + 3].color = particle.color;

	vertexBuffer.vertices[vertexOffset + 4] = vertexBuffer.vertices[vertexOffset + 2];
	vertexBuffer.vertices[vertexOffset + 5] = vertexBuffer.vertices[vertexOffset + 1];
}
