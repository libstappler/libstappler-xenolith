#version 450
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference_uvec2 : require

#include "SPGlslInit.h"
#include "XL2dGlslParticle.h"
#include "XL2dGlslVertexData.h"

layout(buffer_reference) readonly buffer EmitterBuffer;
layout(buffer_reference) readonly buffer EmissionPointsBuffer;
layout(buffer_reference) buffer ParticlesBuffer;
layout(buffer_reference) buffer VerticesBuffer;
layout(buffer_reference) buffer CommandBuffer;

layout (push_constant) uniform PCB {
	ParticleConstantData pcb;
};

layout(std430, buffer_reference, buffer_reference_align = 8) readonly buffer EmitterBuffer {
	ParticleEmitterData data;
};

layout(std430, buffer_reference, buffer_reference_align = 8) readonly buffer EmissionPointsBuffer {
	ParticleEmissionPoints data;
	vec2 points[];
};

layout(std430, buffer_reference, buffer_reference_align = 8) buffer ParticlesBuffer {
	ParticleData particles[];
};

layout(std430, buffer_reference, buffer_reference_align = 8) buffer VerticesBuffer {
	Vertex vertices[];
};

layout(std430, buffer_reference, buffer_reference_align = 8) buffer CommandBuffer {
	ParticleIndirectCommand command;
};

layout(local_size_x = 64) in;

VerticesBuffer vertexBuffer = VerticesBuffer(pcb.outVerticesPointer);
CommandBuffer commandBuffer = CommandBuffer(pcb.outCommandPointer);
ParticlesBuffer particleBuffer = ParticlesBuffer(pcb.particlesPointer);
EmitterBuffer emitterBuffer = EmitterBuffer(pcb.emitterPointer);

#define brand(particle, bound) (pcg16_boundedrand_r(particle.rng, bound))
#define rand(particle) (pcg16_random_r(particle.rng))
#define frand(particle) (pcg16_random_float_r(particle.rng))
#define vrand(particle) (vec2(frand(particle), frand(particle)))

vec2 getNormalFromAngle(float angle) {
	return vec2(cos(angle), sin(angle));
}

vec2 rotateNormalVec(vec2 n, vec2 dA) {
	return n * dA.x + vec2(-n.y, n.x) * dA.y;
}

void emitParticle(inout ParticleData particle) {
	vec2 emissionPoint;
	/*if (emitter.emissionType == 0) {
		EmissionPointsBuffer points = EmissionPointsBuffer(emitter.emissionData);
		uint index = brand(particle, points.data.count);
		emissionPoint = points.points[index];
	}*/

	particle.position = emissionPoint;
	particle.color = emitterBuffer.data.color;

	particle.fullLifetime = uint(ceil((emitterBuffer.data.lifetime.init
			+ emitterBuffer.data.lifetime.rnd * frand(particle)) / emitterBuffer.data.dt));
	particle.currentLifetime = particle.fullLifetime;

	particle.scale = emitterBuffer.data.sizeValue * (emitterBuffer.data.scale.init
			+ emitterBuffer.data.scale.rnd * frand(particle));
	particle.angle = getNormalFromAngle(emitterBuffer.data.angle.init
			+ emitterBuffer.data.angle.rnd * frand(particle));
	particle.normal = getNormalFromAngle(emitterBuffer.data.normal.init
			+ emitterBuffer.data.normal.rnd * frand(particle));

	particle.velocity = emitterBuffer.data.velocity.init
			+ emitterBuffer.data.velocity.rnd * frand(particle);
	particle.linearVelocity = emitterBuffer.data.linearVelocity.init
			+ emitterBuffer.data.linearVelocity.rnd * vrand(particle);

	particle.qAngularVelocity = (getNormalFromAngle(emitterBuffer.data.angularVelocity.init
			+ emitterBuffer.data.angularVelocity.rnd * frand(particle)))
			* emitterBuffer.data.dt;

	particle.orbitalVelocity = emitterBuffer.data.orbitalVelocity.init
			+ emitterBuffer.data.orbitalVelocity.rnd * frand(particle);

	particle.radialVelocity = emitterBuffer.data.radialVelocity.init
			+ emitterBuffer.data.radialVelocity.rnd * frand(particle);

	particle.qAcceleration = (emitterBuffer.data.acceleration.init
			+ emitterBuffer.data.acceleration.rnd * frand(particle))
			* emitterBuffer.data.dt;

	particle.qLinearAcceleration = (emitterBuffer.data.linearAcceleration.init
			+ emitterBuffer.data.linearAcceleration.rnd * vrand(particle))
			* emitterBuffer.data.dt;

	particle.radialAcceleration = emitterBuffer.data.radialAcceleration.init + emitterBuffer.data.radialAcceleration.rnd * frand(particle);
	particle.tangentialAcceleration = emitterBuffer.data.tangentialAcceleration.init + emitterBuffer.data.tangentialAcceleration.rnd * frand(particle);
	particle.hue = emitterBuffer.data.hue.init + emitterBuffer.data.hue.rnd * frand(particle);
}

void simulateParticleFrame(inout ParticleData particle) {
	particle.velocity = particle.velocity + particle.qAcceleration;
	particle.linearVelocity = particle.linearVelocity + particle.qLinearAcceleration;

	vec2 alongNormal = particle.normal * particle.velocity * pcb.dt;
	vec2 linear = particle.linearVelocity * pcb.dt;

	particle.position = particle.position + alongNormal + linear;

	particle.angle = rotateNormalVec(particle.angle, particle.qAngularVelocity);
}

void main() {
	if (gl_GlobalInvocationID.x >= emitterBuffer.data.count) {
		return;
	}

	const float particleProgress = float(gl_GlobalInvocationID.x) / float(emitterBuffer.data.count);

	uint nframes = pcb.nframes;

	ParticleData particle = ParticlesBuffer(pcb.particlesPointer).particles[gl_GlobalInvocationID.x];

	// first - simulate particle

	/*if (nframes > 0) {
		uint keyFrame = uint( floor(pcb.timeline * gl_GlobalInvocationID.x) );

		if (pcb.genframe <= keyFrame && keyFrame < pcb.genframe + nframes ) {
			nframes -= keyFrame - pcb.genframe;

			emitParticle(particle);
		}

		if (particle.currentLifetime <= nframes) {
			particle.currentLifetime = 0;
		} else {
			for (uint i = 0; i < nframes; ++ i) {
				simulateParticleFrame(particle);
			}
			particle.currentLifetime -= nframes;
		}

		particleBuffer.particles[gl_GlobalInvocationID.x] = particle;
	}

	// second - write vertexes for the paticle

	if (particle.currentLifetime == 0) {
		return;
	}*/


	/*vec2 bl = rotateNormalVec(-particle.sizeNormal, particle.angle) * particle.scale;
	vec2 tl = rotateNormalVec(vec2(-particle.sizeNormal.x, particle.sizeNormal.y), particle.angle) * particle.scale;
	vec2 tr = rotateNormalVec(particle.sizeNormal, particle.angle) * particle.scale;
	vec2 br = rotateNormalVec(vec2(particle.sizeNormal.x, -particle.sizeNormal.y), particle.angle) * particle.scale;*/

	const uint vertexOffset = atomicAdd(commandBuffer.command.vertexCount, 6);

	float progressAngle = (particleProgress) * (float(M_PI) * 2.0);
	vec2 normalVec = vec2(cos(progressAngle), sin(progressAngle));
	vec2 pos = normalVec * 50.0 * fract(pcb.gentime + particleProgress);

	vec2 bl = -emitterBuffer.data.sizeNormal * emitterBuffer.data.sizeValue;
	vec2 tl = vec2(-emitterBuffer.data.sizeNormal.x, emitterBuffer.data.sizeNormal.y) * emitterBuffer.data.sizeValue;
	vec2 tr = emitterBuffer.data.sizeNormal * emitterBuffer.data.sizeValue;
	vec2 br = vec2(emitterBuffer.data.sizeNormal.x, -emitterBuffer.data.sizeNormal.y) * emitterBuffer.data.sizeValue;

	const float texLeft = 0.0f;
	const float texRight = 1.0f;
	const float texTop = 0.0f;
	const float texBottom = 1.0f;

	vertexBuffer.vertices[vertexOffset + 0].pos = vec4(pos + bl, 0.0, 1.0);
	vertexBuffer.vertices[vertexOffset + 0].material = pcb.materialIndex;
	vertexBuffer.vertices[vertexOffset + 0].object = 0;
	vertexBuffer.vertices[vertexOffset + 0].tex = vec2(texLeft, texTop);
	vertexBuffer.vertices[vertexOffset + 0].color = vec4(0, 0, 0, 1);

	vertexBuffer.vertices[vertexOffset + 1].pos = vec4(pos + tl, 0.0, 1.0);
	vertexBuffer.vertices[vertexOffset + 1].material = pcb.materialIndex;
	vertexBuffer.vertices[vertexOffset + 1].object = 0;
	vertexBuffer.vertices[vertexOffset + 1].tex = vec2(texLeft, texBottom);
	vertexBuffer.vertices[vertexOffset + 1].color = vec4(0, 0, 0, 1);

	vertexBuffer.vertices[vertexOffset + 2].pos = vec4(pos + br, 0.0, 1.0);
	vertexBuffer.vertices[vertexOffset + 2].material = pcb.materialIndex;
	vertexBuffer.vertices[vertexOffset + 2].object = 0;
	vertexBuffer.vertices[vertexOffset + 2].tex = vec2(texRight, texTop);
	vertexBuffer.vertices[vertexOffset + 2].color = vec4(0, 0, 0, 1);

	vertexBuffer.vertices[vertexOffset + 3].pos = vec4(pos + tr, 0.0, 1.0);
	vertexBuffer.vertices[vertexOffset + 3].material = pcb.materialIndex;
	vertexBuffer.vertices[vertexOffset + 3].object = 0;
	vertexBuffer.vertices[vertexOffset + 3].tex = vec2(texRight, texBottom);
	vertexBuffer.vertices[vertexOffset + 3].color = vec4(0, 0, 0, 1);

	vertexBuffer.vertices[vertexOffset + 4] = vertexBuffer.vertices[vertexOffset + 2];
	vertexBuffer.vertices[vertexOffset + 5] = vertexBuffer.vertices[vertexOffset + 1];
}
