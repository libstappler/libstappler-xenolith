#version 450
#extension GL_GOOGLE_include_directive : enable

#include "XL2dGlslVertexData.h"
#include "XL2dGlslShadowData.h"
#include "XL2dGlslSdfData.h"

layout (local_size_x = 8, local_size_y = 8) in;

#include "XL2dGlslSdfDescriptors.h"

layout(set = 0, binding = 3, r16) uniform writeonly image2D sdfImage;

float polygon3d(in vec3 pt, uint origin, uint count, float value) {
	const float height = abs(value - pt.z);
	const vec2 p = pt.xy;
	float d = dot(p - VERTEX_BUFFER[origin].xy, p - VERTEX_BUFFER[origin].xy);
	float s = 1.0;
	for (int i = 0, j = int(count) - 1; i < int(count); j = i, i++) {
		vec2 e = VERTEX_BUFFER[origin + j].xy - VERTEX_BUFFER[origin + i].xy;
		vec2 w = p - VERTEX_BUFFER[origin + i].xy;
		vec2 b = w - e * clamp(dot(w, e) / dot(e, e), 0.0, 1.0 );
		d = min(d, dot(b, b));
		bvec3 c = bvec3(p.y >= VERTEX_BUFFER[origin + i].y, p.y <VERTEX_BUFFER[origin + j].y, e.x * w.y > e.y * w.x);
		if ( all(c) || all(not(c)) ) s *= -1.0;
	}

	const float ds = s * sqrt(d);
	return sqrt(ds * ds + height * height);
}

void main() {
	const ivec2 imgSize = imageSize(sdfImage);
	const vec2 rel = vec2(float(gl_GlobalInvocationID.x) / float(imgSize.x - 1), float(gl_GlobalInvocationID.y - 1) / float(imgSize.y));
	const vec2 coords = (vec2(float(gl_GlobalInvocationID.x) + 0.5, float(gl_GlobalInvocationID.y) + 0.5))
			* shadowData.shadowSdfDensity;

	const uvec2 cellIdxs = uvec2(floor(coords)) / shadowData.gridSize;
	const uint cellIdx = cellIdxs.y * (shadowData.gridWidth) + cellIdxs.x;

	float value = 128.0;
	float height = 0.0;
	float sdf;

	const uint nObjects = GRID_SIZE_BUFFER[cellIdx];
	const uint targetOffset = cellIdx * shadowData.objectsCount;

	const vec3 coords3d = vec3(coords, shadowData.maxValue);
	
	for (uint i = 0; i < nObjects; ++ i) {
		const Sdf2DObjectData obj = OBJECTS_DATA_BUFFER[GRID_INDEX_BUFFER[targetOffset + i]];
		const TransformData t = TRANSFORM_BUFFER[obj.transform];
		switch (obj.type) {
		case 0:
			sdf = triangle3d(coords3d, obj.a, obj.b, obj.c, obj.value);
			break;
		case 1:
			sdf = circle3d(vec3((t.transform * vec4(coords * shadowData.density, 0.0, 1)).xy, shadowData.maxValue), obj.a,
				obj.b.x * shadowData.density, obj.value, t.padding / shadowData.density);
			break;
		case 2:
			sdf = rect3d(vec3((t.transform * vec4(coords * shadowData.density, 0.0, 1)).xy, shadowData.maxValue), obj.a,
				obj.b * shadowData.density, obj.value, t.padding / shadowData.density);
			break;
		case 3:
			sdf = roundedRect3d(vec3((t.transform * vec4(coords * shadowData.density, 0.0, 1)).xy, shadowData.maxValue), obj.a,
				obj.b * shadowData.density, vec4(obj.c, obj.d) * shadowData.density, obj.value, t.padding / shadowData.density);
			break;
		case 4:
			sdf = polygon3d(coords3d, obj.origin, obj.count, obj.value);
			break;
		}

		if (sdf < value) {
			value = sdf;
			height = obj.value;
		}
	}

	imageStore(sdfImage, ivec2(gl_GlobalInvocationID.x, imgSize.y - gl_GlobalInvocationID.y - 1), vec4(value, height, height, height));
}
