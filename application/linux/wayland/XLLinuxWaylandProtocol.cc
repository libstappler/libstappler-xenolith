/**
 Copyright (c) 2025 Stappler Team <admin@stappler.org>

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 **/

#include "XLLinuxWaylandProtocol.h"
#include "SPLog.h"
#include "XLContextInfo.h"
#include "XLLinuxWaylandLibrary.h"
#include "linux/thirdparty/wayland-protocols/cursor-shape-v1.h"

#include <sys/mman.h>
#include <fcntl.h>
#include <linux/input.h>

namespace STAPPLER_VERSIONIZED stappler::xenolith::platform {

// clang-format off
static const uint8_t s_iconClose[] = {
	0x4c, 0x5a, 0x34, 0x53, 0xab, 0x7, 0xdf, 0xd9, 0xd9, 0xf7, 0xa3, 0x64, 0x64, 0x61, 0x74, 0x61,
	0x59, 0x7, 0x90, 0x0, 0x1, 0x0, 0xff, 0xbd, 0x8f, 0x67, 0x67, 0x67, 0x5c, 0x55, 0x55, 0x55,
	0x6, 0x20, 0x0, 0x5, 0x0, 0x1c, 0x0, 0x0, 0x24, 0x0, 0xf, 0x54, 0x0, 0x1d, 0x8e, 0x67,
	0x67, 0x67, 0xff, 0x67, 0x67, 0x67, 0xb0, 0x5c, 0x0, 0x5, 0x54, 0x0, 0x13, 0xb0, 0x24, 0x0,
	0xf, 0x5c, 0x0, 0x16, 0x83, 0x66, 0x66, 0x66, 0x5, 0x67, 0x67, 0x67, 0xaf, 0x38, 0x0, 0x5b,
	0xb5, 0x6d, 0x6d, 0x6d, 0x7, 0x54, 0x0, 0xe, 0x1c, 0x0, 0xf, 0x5c, 0x0, 0x20, 0x40, 0x68,
	0x68, 0x68, 0xb6, 0x40, 0x0, 0xf, 0x54, 0x0, 0x2d, 0xf, 0xf0, 0x0, 0x4, 0x18, 0xb0, 0xc,
	0x0, 0xf, 0x7c, 0x1, 0x9, 0xf, 0x14, 0x1, 0x20, 0xf, 0xa8, 0x0, 0x2a, 0xe, 0xb4, 0x0,
	0x6, 0x58, 0x0, 0x4, 0x14, 0x1, 0xf, 0x54, 0x0, 0x30, 0x1, 0xfc, 0x0, 0x4f, 0x66, 0x66,
	0x66, 0xb1, 0x8, 0x1, 0x31, 0xf, 0x14, 0x2, 0x1, 0xf, 0xcc, 0x1, 0x1, 0xf, 0x54, 0x0,
	0x2d, 0xf, 0x1c, 0x0, 0x11, 0xf, 0x18, 0x3, 0x15, 0x0, 0xfc, 0x0, 0xf, 0x18, 0x3, 0x39,
	0xf, 0xc8, 0x3, 0x45, 0xf, 0x1, 0x0, 0xff, 0x92, 0xf0, 0x0, 0x66, 0x68, 0x65, 0x69, 0x67,
	0x68, 0x74, 0x16, 0x65, 0x77, 0x69, 0x64, 0x74, 0x68, 0x16,
};

static const uint8_t s_iconCloseActive[] = {
	0x4c, 0x5a, 0x34, 0x53, 0xab, 0x7, 0xdf, 0xd9, 0xd9, 0xf7, 0xa3, 0x64, 0x64, 0x61, 0x74, 0x61,
	0x59, 0x7, 0x90, 0x0, 0x1, 0x0, 0x4, 0xf3, 0x5, 0xb8, 0xb8, 0xb8, 0x12, 0xb4, 0xb4, 0xb4,
	0x62, 0xb4, 0xb4, 0xb4, 0xb0, 0xb3, 0xb3, 0xb3, 0xd8, 0xb3, 0xb3, 0xb3, 0xf4, 0x4, 0x0, 0x0,
	0xc, 0x0, 0xaf, 0xaf, 0xb3, 0xb3, 0xb3, 0x61, 0xb4, 0xb4, 0xb4, 0x11, 0x0, 0x1, 0x0, 0x14,
	0xff, 0x1, 0xaa, 0xaa, 0xaa, 0x9, 0xb2, 0xb2, 0xb2, 0x7b, 0xb3, 0xb3, 0xb3, 0xf1, 0xb3, 0xb3,
	0xb3, 0xff, 0x4, 0x0, 0xc, 0x50, 0xf0, 0xb4, 0xb4, 0xb4, 0x7a, 0x34, 0x0, 0xf, 0x54, 0x0,
	0x9, 0x8f, 0xb1, 0xb1, 0xb1, 0x1a, 0xb3, 0xb3, 0xb3, 0xca, 0x50, 0x0, 0x10, 0xc, 0x4, 0x0,
	0x5f, 0xcf, 0xb3, 0xb3, 0xb3, 0x1e, 0x54, 0x0, 0x1, 0x8f, 0xb6, 0xb6, 0xb6, 0x1c, 0xb3, 0xb3,
	0xb3, 0xe4, 0x54, 0x0, 0x20, 0x4, 0x4, 0x0, 0x5c, 0xe3, 0xb3, 0xb3, 0xb3, 0x1b, 0xfc, 0x0,
	0x4f, 0xb3, 0xb3, 0xb3, 0xcd, 0x54, 0x0, 0x28, 0x1, 0x4, 0x0, 0x84, 0xb2, 0xb2, 0xb2, 0xcb,
	0xbf, 0xbf, 0xbf, 0x8, 0x58, 0x0, 0x4c, 0xb4, 0xb4, 0xb4, 0x7d, 0x24, 0x0, 0x7f, 0xce, 0xce,
	0xce, 0xff, 0xb5, 0xb5, 0xb5, 0x44, 0x0, 0x6, 0x0, 0x1c, 0x0, 0x0, 0x24, 0x0, 0x1e, 0xb3,
	0x1c, 0x0, 0x14, 0x78, 0xf8, 0x1, 0xc, 0xa4, 0x1, 0x0, 0x30, 0x0, 0x0, 0x1, 0x0, 0x3e,
	0xe7, 0xe7, 0xe7, 0x5c, 0x0, 0x3, 0x54, 0x0, 0x0, 0x1c, 0x0, 0x0, 0x1, 0x0, 0xe, 0x5c,
	0x0, 0x1, 0xcc, 0x1, 0x5c, 0x11, 0xb2, 0xb2, 0xb2, 0x63, 0x38, 0x0, 0x35, 0xb4, 0xb4, 0xb4,
	0x38, 0x0, 0x39, 0xe9, 0xe9, 0xe9, 0x5c, 0x0, 0x8, 0x54, 0x0, 0xc, 0x1c, 0x0, 0x7, 0x10,
	0x1, 0x13, 0x60, 0xa0, 0x2, 0x1f, 0xff, 0x5c, 0x0, 0x11, 0xf, 0x54, 0x0, 0x11, 0x3, 0x4,
	0x0, 0x5e, 0xae, 0xb3, 0xb3, 0xb3, 0xdb, 0x44, 0x1, 0xe, 0x9c, 0x0, 0x0, 0x8, 0x0, 0x8,
	0xc, 0x0, 0xf, 0x7c, 0x1, 0x9, 0x3, 0x3c, 0x3, 0x1f, 0xf3, 0xe4, 0x1, 0x9, 0x8, 0xb8,
	0x0, 0xf, 0xa8, 0x0, 0x10, 0x4, 0x4, 0x0, 0x1e, 0xf3, 0x58, 0x0, 0xe, 0xb4, 0x0, 0xf,
	0x58, 0x0, 0x20, 0x0, 0x8, 0x2, 0x1f, 0xd9, 0x54, 0x0, 0x11, 0x3f, 0xe8, 0xe8, 0xe8, 0x8,
	0x1, 0x19, 0x13, 0xd7, 0x44, 0x4, 0xf, 0xb8, 0x1, 0x12, 0xf, 0x28, 0x2, 0x9, 0xb, 0x10,
	0x2, 0x10, 0xad, 0x98, 0x4, 0xf, 0x68, 0x2, 0x19, 0xf, 0x5c, 0x0, 0x14, 0x13, 0x5e, 0x18,
	0x3, 0x1e, 0xf0, 0x18, 0x3, 0x2, 0xfc, 0x0, 0xf, 0x18, 0x3, 0x20, 0x53, 0xef, 0xaf, 0xaf,
	0xaf, 0x10, 0xc8, 0x3, 0x1f, 0x7a, 0xc8, 0x3, 0x38, 0x14, 0x76, 0x20, 0x4, 0x0, 0x2c, 0x4,
	0x0, 0x34, 0x4, 0xf, 0x78, 0x4, 0x2c, 0x0, 0x4, 0x0, 0x18, 0xc9, 0x78, 0x4, 0x0, 0x1,
	0x0, 0x0, 0xe4, 0x4, 0x3, 0xec, 0x4, 0xf, 0x54, 0x0, 0x25, 0x10, 0xe2, 0xc0, 0x5, 0xf,
	0xd8, 0x5, 0x8, 0x1f, 0xc9, 0x54, 0x0, 0x20, 0x1f, 0xce, 0xd8, 0x5, 0x5, 0x8, 0x14, 0x1,
	0x0, 0xec, 0x4, 0xc, 0xcc, 0x1, 0xf, 0x4, 0x0, 0x4, 0x10, 0xef, 0x50, 0x1, 0x4f, 0xb6,
	0xb6, 0xb6, 0x7, 0xe8, 0x6, 0x15, 0x3, 0xec, 0x4, 0x13, 0x60, 0xe0, 0x2, 0x17, 0xd7, 0x9c,
	0x3, 0x10, 0xd7, 0x58, 0x4, 0x44, 0xb4, 0xb4, 0xb4, 0x5f, 0xf8, 0x1, 0xf, 0x1, 0x0, 0x1,
	0xf0, 0x0, 0x66, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x16, 0x65, 0x77, 0x69, 0x64, 0x74, 0x68,
	0x16,
};

static const uint8_t s_iconMaximize[] = {
	0x4c, 0x5a, 0x34, 0x53, 0xab, 0x7, 0xdf, 0xd9, 0xd9, 0xf7, 0xa3, 0x64, 0x64, 0x61, 0x74, 0x61,
	0x59, 0x7, 0x90, 0x0, 0x1, 0x0, 0xff, 0xb9, 0x8f, 0x64, 0x64, 0x64, 0x40, 0x66, 0x66, 0x66,
	0x80, 0x4, 0x0, 0x11, 0x0, 0x2c, 0x0, 0xf, 0x58, 0x0, 0x15, 0x0, 0x30, 0x0, 0x8f, 0x65,
	0x65, 0x65, 0xfc, 0x65, 0x65, 0x65, 0xe0, 0x4, 0x0, 0xc, 0x10, 0xfc, 0x2c, 0x0, 0xf, 0x58,
	0x0, 0x1c, 0x1f, 0xe0, 0x28, 0x0, 0xd, 0x0, 0x24, 0x0, 0xf, 0x58, 0x0, 0xff, 0xff, 0x8a,
	0xf, 0x18, 0x3, 0x3e, 0xf, 0xc8, 0x3, 0x45, 0xf, 0x1, 0x0, 0xff, 0x92, 0xf0, 0x0, 0x66,
	0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x16, 0x65, 0x77, 0x69, 0x64, 0x74, 0x68, 0x16,
};

static const uint8_t s_iconMaximizeActive[] = {
	0x4c, 0x5a, 0x34, 0x53, 0xab, 0x7, 0xdf, 0xd9, 0xd9, 0xf7, 0xa3, 0x64, 0x64, 0x61, 0x74, 0x61,
	0x59, 0x7, 0x90, 0x0, 0x1, 0x0, 0x4, 0xf3, 0x5, 0xb8, 0xb8, 0xb8, 0x12, 0xb4, 0xb4, 0xb4,
	0x62, 0xb4, 0xb4, 0xb4, 0xb0, 0xb3, 0xb3, 0xb3, 0xd8, 0xb3, 0xb3, 0xb3, 0xf4, 0x4, 0x0, 0x0,
	0xc, 0x0, 0xaf, 0xaf, 0xb3, 0xb3, 0xb3, 0x61, 0xb4, 0xb4, 0xb4, 0x11, 0x0, 0x1, 0x0, 0x14,
	0xff, 0x1, 0xaa, 0xaa, 0xaa, 0x9, 0xb2, 0xb2, 0xb2, 0x7b, 0xb3, 0xb3, 0xb3, 0xf1, 0xb3, 0xb3,
	0xb3, 0xff, 0x4, 0x0, 0xc, 0x50, 0xf0, 0xb4, 0xb4, 0xb4, 0x7a, 0x34, 0x0, 0xf, 0x54, 0x0,
	0x9, 0x8f, 0xb1, 0xb1, 0xb1, 0x1a, 0xb3, 0xb3, 0xb3, 0xca, 0x50, 0x0, 0x10, 0xc, 0x4, 0x0,
	0x5f, 0xcf, 0xb3, 0xb3, 0xb3, 0x1e, 0x54, 0x0, 0x1, 0x8f, 0xb6, 0xb6, 0xb6, 0x1c, 0xb3, 0xb3,
	0xb3, 0xe4, 0x54, 0x0, 0x20, 0x4, 0x4, 0x0, 0x5c, 0xe3, 0xb3, 0xb3, 0xb3, 0x1b, 0xfc, 0x0,
	0x4f, 0xb3, 0xb3, 0xb3, 0xcd, 0x54, 0x0, 0x28, 0x1, 0x4, 0x0, 0x84, 0xb2, 0xb2, 0xb2, 0xcb,
	0xbf, 0xbf, 0xbf, 0x8, 0x58, 0x0, 0x48, 0xb4, 0xb4, 0xb4, 0x7d, 0x20, 0x0, 0x7f, 0xc6, 0xc6,
	0xc6, 0xff, 0xd9, 0xd9, 0xd9, 0x4, 0x0, 0x12, 0x0, 0x2c, 0x0, 0xb, 0x60, 0x0, 0x14, 0x78,
	0xf8, 0x1, 0xc, 0xa4, 0x1, 0x0, 0x30, 0x0, 0x7f, 0xfe, 0xfe, 0xfe, 0xff, 0xf6, 0xf6, 0xf6,
	0x4, 0x0, 0xa, 0x0, 0x24, 0x0, 0x0, 0x2c, 0x0, 0x1e, 0xb3, 0xcc, 0x1, 0x5c, 0x11, 0xb2,
	0xb2, 0xb2, 0x63, 0xd0, 0x0, 0x0, 0x2c, 0x0, 0x0, 0x38, 0x0, 0xf, 0xf8, 0x0, 0xd, 0x0,
	0x24, 0x0, 0xe, 0x58, 0x0, 0x1, 0x10, 0x1, 0x13, 0x60, 0xa0, 0x2, 0xf, 0x58, 0x0, 0x39,
	0x0, 0x4, 0x0, 0x5f, 0xae, 0xb3, 0xb3, 0xb3, 0xdb, 0x58, 0x0, 0x40, 0x0, 0x3c, 0x3, 0x1f,
	0xf3, 0x58, 0x0, 0x40, 0x1f, 0xf3, 0x58, 0x0, 0x44, 0x0, 0x8, 0x2, 0x1f, 0xd9, 0x58, 0x0,
	0x40, 0x13, 0xd7, 0x44, 0x4, 0xf, 0x10, 0x2, 0x3d, 0x10, 0xad, 0x98, 0x4, 0xf, 0xb0, 0x0,
	0x40, 0x13, 0x5e, 0x18, 0x3, 0x1f, 0xf0, 0x18, 0x3, 0x38, 0x53, 0xef, 0xaf, 0xaf, 0xaf, 0x10,
	0xc8, 0x3, 0x1f, 0x7a, 0xc8, 0x3, 0x38, 0x14, 0x76, 0x20, 0x4, 0x0, 0x2c, 0x4, 0x0, 0x34,
	0x4, 0xf, 0x78, 0x4, 0x2c, 0x0, 0x4, 0x0, 0x18, 0xc9, 0x78, 0x4, 0x0, 0x1, 0x0, 0x0,
	0xe4, 0x4, 0x3, 0xec, 0x4, 0xf, 0x54, 0x0, 0x25, 0x10, 0xe2, 0xc0, 0x5, 0xf, 0xd8, 0x5,
	0x8, 0x1f, 0xc9, 0x54, 0x0, 0x20, 0x1f, 0xce, 0xd8, 0x5, 0x5, 0x8, 0x14, 0x1, 0x0, 0xec,
	0x4, 0xc, 0xcc, 0x1, 0xf, 0x4, 0x0, 0x4, 0x10, 0xef, 0x50, 0x1, 0x4f, 0xb6, 0xb6, 0xb6,
	0x7, 0xe8, 0x6, 0x15, 0x3, 0xec, 0x4, 0x13, 0x60, 0xe0, 0x2, 0x17, 0xd7, 0x9c, 0x3, 0x10,
	0xd7, 0x58, 0x4, 0x44, 0xb4, 0xb4, 0xb4, 0x5f, 0xf8, 0x1, 0xf, 0x1, 0x0, 0x1, 0xf0, 0x0,
	0x66, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x16, 0x65, 0x77, 0x69, 0x64, 0x74, 0x68, 0x16,
};

static const uint8_t s_iconMinimize[] = {
	0x4c, 0x5a, 0x34, 0x53, 0xab, 0x7, 0xdf, 0xd9, 0xd9, 0xf7, 0xa3, 0x64, 0x64, 0x61, 0x74, 0x61,
	0x59, 0x7, 0x90, 0x0, 0x1, 0x0, 0xff, 0xff, 0xff, 0xff, 0x7c, 0x8f, 0x68, 0x68, 0x68, 0x20,
	0x64, 0x64, 0x64, 0x40, 0x4, 0x0, 0x11, 0x0, 0x2c, 0x0, 0xf, 0x58, 0x0, 0x15, 0x8f, 0x66,
	0x66, 0x66, 0x80, 0x65, 0x65, 0x65, 0xff, 0x4, 0x0, 0x11, 0x0, 0x2c, 0x0, 0xf, 0x58, 0x0,
	0x15, 0x40, 0x60, 0x60, 0x60, 0x10, 0x88, 0x0, 0xf, 0x4, 0x0, 0x11, 0x0, 0x2c, 0x0, 0xf,
	0x4, 0x3, 0xff, 0xff, 0x13, 0xf0, 0x0, 0x66, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x16, 0x65,
	0x77, 0x69, 0x64, 0x74, 0x68, 0x16,
};

static const uint8_t s_iconMinimizeActive[] = {
	0x4c, 0x5a, 0x34, 0x53, 0xab, 0x7, 0xdf, 0xd9, 0xd9, 0xf7, 0xa3, 0x64, 0x64, 0x61, 0x74, 0x61,
	0x59, 0x7, 0x90, 0x0, 0x1, 0x0, 0x4, 0xf3, 0x5, 0xb8, 0xb8, 0xb8, 0x12, 0xb4, 0xb4, 0xb4,
	0x62, 0xb4, 0xb4, 0xb4, 0xb0, 0xb3, 0xb3, 0xb3, 0xd8, 0xb3, 0xb3, 0xb3, 0xf4, 0x4, 0x0, 0x0,
	0xc, 0x0, 0xaf, 0xaf, 0xb3, 0xb3, 0xb3, 0x61, 0xb4, 0xb4, 0xb4, 0x11, 0x0, 0x1, 0x0, 0x14,
	0xff, 0x1, 0xaa, 0xaa, 0xaa, 0x9, 0xb2, 0xb2, 0xb2, 0x7b, 0xb3, 0xb3, 0xb3, 0xf1, 0xb3, 0xb3,
	0xb3, 0xff, 0x4, 0x0, 0xc, 0x50, 0xf0, 0xb4, 0xb4, 0xb4, 0x7a, 0x34, 0x0, 0xf, 0x54, 0x0,
	0x9, 0x8f, 0xb1, 0xb1, 0xb1, 0x1a, 0xb3, 0xb3, 0xb3, 0xca, 0x50, 0x0, 0x10, 0xc, 0x4, 0x0,
	0x5f, 0xcf, 0xb3, 0xb3, 0xb3, 0x1e, 0x54, 0x0, 0x1, 0x8f, 0xb6, 0xb6, 0xb6, 0x1c, 0xb3, 0xb3,
	0xb3, 0xe4, 0x54, 0x0, 0x20, 0x4, 0x4, 0x0, 0x5c, 0xe3, 0xb3, 0xb3, 0xb3, 0x1b, 0xfc, 0x0,
	0x4f, 0xb3, 0xb3, 0xb3, 0xcd, 0x54, 0x0, 0x28, 0x1, 0x4, 0x0, 0x84, 0xb2, 0xb2, 0xb2, 0xcb,
	0xbf, 0xbf, 0xbf, 0x8, 0x58, 0x0, 0x4f, 0xb4, 0xb4, 0xb4, 0x7d, 0x54, 0x0, 0x2d, 0x7, 0x4,
	0x0, 0x14, 0x78, 0xf8, 0x1, 0xe, 0xa4, 0x1, 0xf, 0x4, 0x0, 0x2a, 0x10, 0xf0, 0x28, 0x2,
	0x4f, 0xb2, 0xb2, 0xb2, 0x63, 0x54, 0x0, 0x38, 0x4, 0x10, 0x1, 0x13, 0x60, 0xa0, 0x2, 0x1f,
	0xff, 0x4, 0x0, 0x3c, 0x5f, 0xae, 0xb3, 0xb3, 0xb3, 0xdb, 0x58, 0x0, 0x40, 0x0, 0x3c, 0x3,
	0x1f, 0xf3, 0x58, 0x0, 0x40, 0x1f, 0xf3, 0x58, 0x0, 0x44, 0x0, 0x8, 0x2, 0x1f, 0xd9, 0x58,
	0x0, 0x40, 0x13, 0xd7, 0x44, 0x4, 0x9, 0x18, 0x0, 0x7f, 0xbd, 0xbd, 0xbd, 0xff, 0xc6, 0xc6,
	0xc6, 0x4, 0x0, 0x12, 0x0, 0x2c, 0x0, 0x1e, 0xb3, 0x10, 0x2, 0x10, 0xad, 0x98, 0x4, 0xc,
	0x18, 0x0, 0x4f, 0xd9, 0xd9, 0xd9, 0xff, 0x1, 0x0, 0x15, 0x0, 0x2c, 0x0, 0x1e, 0xb3, 0xb0,
	0x0, 0x13, 0x5e, 0x18, 0x3, 0x18, 0xf0, 0x18, 0x0, 0x31, 0xb8, 0xb8, 0xb8, 0x88, 0x0, 0xf,
	0x4, 0x0, 0x11, 0x0, 0x2c, 0x0, 0xb, 0x54, 0x0, 0x53, 0xef, 0xaf, 0xaf, 0xaf, 0x10, 0xc8,
	0x3, 0x1f, 0x7a, 0x5c, 0x1, 0x38, 0x14, 0x76, 0x20, 0x4, 0x0, 0x2c, 0x4, 0x0, 0x34, 0x4,
	0xf, 0x54, 0x0, 0x30, 0x18, 0xc9, 0x78, 0x4, 0x0, 0x1, 0x0, 0x0, 0xe4, 0x4, 0x3, 0xec,
	0x4, 0xf, 0x54, 0x0, 0x25, 0x10, 0xe2, 0xc0, 0x5, 0xf, 0xd8, 0x5, 0x8, 0x1f, 0xc9, 0x54,
	0x0, 0x20, 0x1f, 0xce, 0xd8, 0x5, 0x5, 0x8, 0x14, 0x1, 0x0, 0xec, 0x4, 0xc, 0xcc, 0x1,
	0xf, 0x4, 0x0, 0x4, 0x10, 0xef, 0x50, 0x1, 0x4f, 0xb6, 0xb6, 0xb6, 0x7, 0xe8, 0x6, 0x15,
	0x3, 0xec, 0x4, 0x13, 0x60, 0xe0, 0x2, 0x17, 0xd7, 0x9c, 0x3, 0x10, 0xd7, 0x58, 0x4, 0x44,
	0xb4, 0xb4, 0xb4, 0x5f, 0xf8, 0x1, 0xf, 0x1, 0x0, 0x1, 0xf0, 0x0, 0x66, 0x68, 0x65, 0x69,
	0x67, 0x68, 0x74, 0x16, 0x65, 0x77, 0x69, 0x64, 0x74, 0x68, 0x16,
};

static const uint8_t s_iconRestore[] = {
	0x4c, 0x5a, 0x34, 0x53, 0xab, 0x7, 0xdf, 0xd9, 0xd9, 0xf7, 0xa3, 0x64, 0x64, 0x61, 0x74, 0x61,
	0x59, 0x7, 0x90, 0x0, 0x1, 0x0, 0xff, 0xc5, 0x8f, 0x65, 0x65, 0x65, 0x30, 0x68, 0x68, 0x68,
	0x40, 0x4, 0x0, 0x8, 0x1f, 0x20, 0x58, 0x0, 0x21, 0x8f, 0x67, 0x67, 0x67, 0x54, 0x66, 0x66,
	0x66, 0x70, 0x4, 0x0, 0x1, 0x40, 0x65, 0x65, 0x65, 0x7e, 0x5c, 0x0, 0xf, 0xcc, 0x0, 0x3d,
	0x0, 0x5c, 0x0, 0xf, 0x58, 0x0, 0x18, 0x0, 0xfc, 0x0, 0x5f, 0x60, 0x65, 0x65, 0x65, 0xc0,
	0x4, 0x0, 0x8, 0x1f, 0x90, 0x58, 0x0, 0x20, 0x0, 0x30, 0x0, 0x9c, 0x80, 0x65, 0x65, 0x65,
	0xf4, 0x64, 0x64, 0x64, 0xa0, 0x4, 0x0, 0x40, 0x65, 0x65, 0x65, 0xdc, 0x5c, 0x0, 0xf, 0x58,
	0x0, 0x28, 0x1f, 0xe0, 0x1c, 0x0, 0x1, 0x3, 0x5c, 0x0, 0xf, 0x58, 0x0, 0xfa, 0x0, 0x84,
	0x2, 0x0, 0xe0, 0x2, 0xf, 0x58, 0x0, 0x3d, 0xf, 0x98, 0x2, 0x20, 0x0, 0x58, 0x0, 0x10,
	0xfc, 0x5c, 0x0, 0x1e, 0x65, 0x4, 0x0, 0x1f, 0xf4, 0x58, 0x0, 0x24, 0x0, 0x94, 0x0, 0x10,
	0x40, 0x5c, 0x0, 0xf, 0x4, 0x0, 0x5, 0x0, 0xe0, 0x2, 0xf, 0xb8, 0x5, 0xff, 0xc6, 0xf0,
	0x0, 0x66, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x16, 0x65, 0x77, 0x69, 0x64, 0x74, 0x68, 0x16,
};

static const uint8_t s_iconRestoreActive[] = {
	0x4c, 0x5a, 0x34, 0x53, 0xab, 0x7, 0xdf, 0xd9, 0xd9, 0xf7, 0xa3, 0x64, 0x64, 0x61, 0x74, 0x61,
	0x59, 0x7, 0x90, 0x0, 0x1, 0x0, 0x4, 0xf3, 0x5, 0xb8, 0xb8, 0xb8, 0x12, 0xb1, 0xb1, 0xb1,
	0x62, 0xb2, 0xb2, 0xb2, 0xb0, 0xb2, 0xb2, 0xb2, 0xd8, 0xb2, 0xb2, 0xb2, 0xf4, 0x4, 0x0, 0x0,
	0xc, 0x0, 0xaf, 0xaf, 0xb3, 0xb3, 0xb3, 0x61, 0xb4, 0xb4, 0xb4, 0x11, 0x0, 0x1, 0x0, 0x14,
	0xff, 0x1, 0xaa, 0xaa, 0xaa, 0x9, 0xb2, 0xb2, 0xb2, 0x7b, 0xb2, 0xb2, 0xb2, 0xf1, 0xb2, 0xb2,
	0xb2, 0xff, 0x4, 0x0, 0x9, 0x80, 0xb3, 0xb3, 0xb3, 0xf0, 0xb2, 0xb2, 0xb2, 0x7a, 0x34, 0x0,
	0xf, 0x54, 0x0, 0x9, 0x8f, 0xb1, 0xb1, 0xb1, 0x1a, 0xb2, 0xb2, 0xb2, 0xca, 0x50, 0x0, 0xd,
	0xc, 0x4, 0x0, 0x8f, 0xb1, 0xb1, 0xb1, 0xcf, 0xb3, 0xb3, 0xb3, 0x1e, 0x54, 0x0, 0x1, 0x8f,
	0xb6, 0xb6, 0xb6, 0x1c, 0xb2, 0xb2, 0xb2, 0xe4, 0x54, 0x0, 0x1d, 0x7, 0x5c, 0x0, 0x6e, 0xe3,
	0xb3, 0xb3, 0xb3, 0x1b, 0x0, 0xfc, 0x0, 0x1f, 0xcd, 0x54, 0x0, 0x25, 0x7, 0x4, 0x0, 0x57,
	0xcb, 0xbf, 0xbf, 0xbf, 0x8, 0x0, 0x1, 0x1f, 0x7d, 0x2c, 0x0, 0x5, 0x7f, 0xc0, 0xc0, 0xc0,
	0xff, 0xc5, 0xc5, 0xc5, 0x4, 0x0, 0x6, 0x3c, 0xbc, 0xbc, 0xbc, 0x74, 0x1, 0x14, 0x78, 0xf8,
	0x1, 0xf, 0xa4, 0x1, 0x9, 0x7f, 0xcb, 0xcb, 0xcb, 0xff, 0xd4, 0xd4, 0xd4, 0x4, 0x0, 0x2,
	0x31, 0xd8, 0xd8, 0xd8, 0x5c, 0x0, 0xc, 0xcc, 0x1, 0x0, 0x28, 0x2, 0x4f, 0xb2, 0xb2, 0xb2,
	0x63, 0xf8, 0x0, 0x25, 0x0, 0x5c, 0x0, 0xc, 0x58, 0x0, 0x3, 0x4, 0x0, 0x13, 0x60, 0xa0,
	0x2, 0x9, 0x18, 0x0, 0x7f, 0xcf, 0xcf, 0xcf, 0xff, 0xec, 0xec, 0xec, 0x4, 0x0, 0x6, 0x3e,
	0xdd, 0xdd, 0xdd, 0x58, 0x0, 0xa, 0xc4, 0x1, 0x5c, 0xae, 0xb2, 0xb2, 0xb2, 0xdb, 0x18, 0x0,
	0xbd, 0xd9, 0xd9, 0xd9, 0xff, 0xfc, 0xfc, 0xfc, 0xff, 0xe2, 0xe2, 0xe2, 0x4, 0x0, 0x31, 0xf4,
	0xf4, 0xf4, 0x5c, 0x0, 0xf, 0xb0, 0x0, 0xc, 0x0, 0x3c, 0x3, 0x1f, 0xf3, 0x58, 0x0, 0x1,
	0x3f, 0xf6, 0xf6, 0xf6, 0xfc, 0x0, 0x2, 0x0, 0x5c, 0x0, 0xf, 0x58, 0x0, 0x10, 0x1f, 0xf3,
	0x58, 0x0, 0x44, 0x5f, 0xf1, 0xb1, 0xb1, 0xb1, 0xd9, 0x58, 0x0, 0x40, 0x10, 0xd7, 0x44, 0x4,
	0xf, 0x58, 0x0, 0x25, 0x0, 0x84, 0x2, 0x0, 0xe0, 0x2, 0x1e, 0xb2, 0x28, 0x0, 0x10, 0xad,
	0x98, 0x4, 0xf, 0x58, 0x0, 0x25, 0xf, 0x90, 0x4, 0x8, 0x10, 0x5e, 0x18, 0x3, 0x3, 0x98,
	0x4, 0x9, 0x58, 0x0, 0x31, 0xfe, 0xfe, 0xfe, 0x5c, 0x0, 0xc, 0x4, 0x0, 0x0, 0x28, 0x2,
	0xf, 0x58, 0x0, 0xc, 0x50, 0xef, 0xaf, 0xaf, 0xaf, 0x10, 0x74, 0x3, 0x0, 0xec, 0x4, 0x8,
	0x1c, 0x0, 0x0, 0x34, 0x1, 0x0, 0x5c, 0x0, 0xf, 0x4, 0x0, 0x5, 0x0, 0xe0, 0x2, 0xf,
	0x80, 0x4, 0x8, 0x14, 0x76, 0x20, 0x4, 0x0, 0x2c, 0x4, 0x0, 0x34, 0x4, 0xf, 0x78, 0x4,
	0x30, 0x18, 0xc9, 0x78, 0x4, 0x0, 0x1, 0x0, 0x0, 0xe4, 0x4, 0x0, 0xec, 0x4, 0xf, 0x54,
	0x0, 0x28, 0x10, 0xe2, 0xc0, 0x5, 0xf, 0xd8, 0x5, 0x8, 0x1f, 0xc9, 0x54, 0x0, 0x20, 0x1f,
	0xce, 0xd8, 0x5, 0x5, 0x8, 0x14, 0x1, 0x0, 0xec, 0x4, 0xc, 0xcc, 0x1, 0xf, 0xa4, 0x1,
	0x5, 0x0, 0x50, 0x1, 0x4f, 0xb6, 0xb6, 0xb6, 0x7, 0xe8, 0x6, 0x15, 0x3, 0xec, 0x4, 0x13,
	0x60, 0xe0, 0x2, 0x17, 0xd7, 0x9c, 0x3, 0x10, 0xd7, 0x58, 0x4, 0x44, 0xb1, 0xb1, 0xb1, 0x5f,
	0xf8, 0x1, 0xf, 0x1, 0x0, 0x1, 0xf0, 0x0, 0x66, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x16,
	0x65, 0x77, 0x69, 0x64, 0x74, 0x68, 0x16,
};

// clang-format on

ViewporterInterface::ViewporterInterface(const struct wl_interface *wl_surface_interface)
: viewporter_types{
	NULL,
	NULL,
	NULL,
	NULL,
	&wp_viewport_interface,
	wl_surface_interface
}, wp_viewporter_requests{
	{ "destroy", "", viewporter_types + 0 },
	{ "get_viewport", "no", viewporter_types + 4 },
}, wp_viewport_requests{
	{ "destroy", "", viewporter_types + 0 },
	{ "set_source", "ffff", viewporter_types + 0 },
	{ "set_destination", "ii", viewporter_types + 0 },
}, wp_viewporter_interface{
	"wp_viewporter", 1,
	2, wp_viewporter_requests,
	0, NULL,
}, wp_viewport_interface{
	"wp_viewport", 1,
	3, wp_viewport_requests,
	0, NULL,
} { }

XdgInterface::XdgInterface(const struct wl_interface *wl_output_interface, const struct wl_interface *wl_seat_interface,
		const struct wl_interface *wl_surface_interface)
: xdg_shell_types{
	NULL,
	NULL,
	NULL,
	NULL,
	&xdg_positioner_interface,
	&xdg_surface_interface,
	wl_surface_interface,
	&xdg_toplevel_interface,
	&xdg_popup_interface,
	&xdg_surface_interface,
	&xdg_positioner_interface,
	&xdg_toplevel_interface,
	wl_seat_interface,
	NULL,
	NULL,
	NULL,
	wl_seat_interface,
	NULL,
	wl_seat_interface,
	NULL,
	NULL,
	wl_output_interface,
	wl_seat_interface,
	NULL,
	&xdg_positioner_interface,
	NULL,
}, xdg_wm_base_requests{
	{ "destroy", "", xdg_shell_types + 0 },
	{ "create_positioner", "n", xdg_shell_types + 4 },
	{ "get_xdg_surface", "no", xdg_shell_types + 5 },
	{ "pong", "u", xdg_shell_types + 0 },
}, xdg_wm_base_events{
	{ "ping", "u", xdg_shell_types + 0 },
}, xdg_positioner_requests{
	{ "destroy", "", xdg_shell_types + 0 },
	{ "set_size", "ii", xdg_shell_types + 0 },
	{ "set_anchor_rect", "iiii", xdg_shell_types + 0 },
	{ "set_anchor", "u", xdg_shell_types + 0 },
	{ "set_gravity", "u", xdg_shell_types + 0 },
	{ "set_constraint_adjustment", "u", xdg_shell_types + 0 },
	{ "set_offset", "ii", xdg_shell_types + 0 },
	{ "set_reactive", "3", xdg_shell_types + 0 },
	{ "set_parent_size", "3ii", xdg_shell_types + 0 },
	{ "set_parent_configure", "3u", xdg_shell_types + 0 },
}, xdg_surface_requests{
	{ "destroy", "", xdg_shell_types + 0 },
	{ "get_toplevel", "n", xdg_shell_types + 7 },
	{ "get_popup", "n?oo", xdg_shell_types + 8 },
	{ "set_window_geometry", "iiii", xdg_shell_types + 0 },
	{ "ack_configure", "u", xdg_shell_types + 0 },
}, xdg_surface_events{
	{ "configure", "u", xdg_shell_types + 0 },
}, xdg_toplevel_requests{
	{ "destroy", "", xdg_shell_types + 0 },
	{ "set_parent", "?o", xdg_shell_types + 11 },
	{ "set_title", "s", xdg_shell_types + 0 },
	{ "set_app_id", "s", xdg_shell_types + 0 },
	{ "show_window_menu", "ouii", xdg_shell_types + 12 },
	{ "move", "ou", xdg_shell_types + 16 },
	{ "resize", "ouu", xdg_shell_types + 18 },
	{ "set_max_size", "ii", xdg_shell_types + 0 },
	{ "set_min_size", "ii", xdg_shell_types + 0 },
	{ "set_maximized", "", xdg_shell_types + 0 },
	{ "unset_maximized", "", xdg_shell_types + 0 },
	{ "set_fullscreen", "?o", xdg_shell_types + 21 },
	{ "unset_fullscreen", "", xdg_shell_types + 0 },
	{ "set_minimized", "", xdg_shell_types + 0 },
}, xdg_toplevel_events{
	{ "configure", "iia", xdg_shell_types + 0 },
	{ "close", "", xdg_shell_types + 0 },
	{ "configure_bounds", "4ii", xdg_shell_types + 0 },
	{ "wm_capabilities", "5a", xdg_shell_types + 0 },
}, xdg_popup_requests{
	{ "destroy", "", xdg_shell_types + 0 },
	{ "grab", "ou", xdg_shell_types + 22 },
	{ "reposition", "3ou", xdg_shell_types + 24 },
}, xdg_popup_events{
	{ "configure", "iiii", xdg_shell_types + 0 },
	{ "popup_done", "", xdg_shell_types + 0 },
	{ "repositioned", "3u", xdg_shell_types + 0 },
}, xdg_wm_base_interface{
	"xdg_wm_base", 7,
	4, xdg_wm_base_requests,
	1, xdg_wm_base_events,
}, xdg_positioner_interface{
	"xdg_positioner", 7,
	10, xdg_positioner_requests,
	0, NULL,
}, xdg_surface_interface{
	"xdg_surface", 7,
	5, xdg_surface_requests,
	1, xdg_surface_events,
}, xdg_toplevel_interface{
	"xdg_toplevel", 7,
	14, xdg_toplevel_requests,
	4, xdg_toplevel_events,
}, xdg_popup_interface{
	"xdg_popup", 7,
	3, xdg_popup_requests,
	3, xdg_popup_events,
} { }

XdgDecorationInterface::XdgDecorationInterface(const struct wl_interface *xdg_toplevel_interface)
: xdg_decoration_unstable_v1_types{
	NULL,
	&zxdg_toplevel_decoration_v1_interface,
	xdg_toplevel_interface,
},
zxdg_decoration_manager_v1_requests{
	{ "destroy", "", xdg_decoration_unstable_v1_types + 0 },
	{ "get_toplevel_decoration", "no", xdg_decoration_unstable_v1_types + 1 },
},
zxdg_toplevel_decoration_v1_requests{
	{ "destroy", "", xdg_decoration_unstable_v1_types + 0 },
	{ "set_mode", "u", xdg_decoration_unstable_v1_types + 0 },
	{ "unset_mode", "", xdg_decoration_unstable_v1_types + 0 },
},
zxdg_toplevel_decoration_v1_events{
	{ "configure", "u", xdg_decoration_unstable_v1_types + 0 },
},
zxdg_decoration_manager_v1_interface{
	"zxdg_decoration_manager_v1", 1,
	2, zxdg_decoration_manager_v1_requests,
	0, NULL,
},
zxdg_toplevel_decoration_v1_interface{
	"zxdg_toplevel_decoration_v1", 1,
	3, zxdg_toplevel_decoration_v1_requests,
	1, zxdg_toplevel_decoration_v1_events,
} { }

CursorShapeInterface::CursorShapeInterface(const struct wl_interface *wl_pointer_interface)
: cursor_shape_v1_types{
	NULL,
	NULL,
	&wp_cursor_shape_device_v1_interface,
	wl_pointer_interface,
	&wp_cursor_shape_device_v1_interface,
	nullptr,
},
wp_cursor_shape_manager_v1_requests{
	{ "destroy", "", cursor_shape_v1_types + 0 },
	{ "get_pointer", "no", cursor_shape_v1_types + 2 },
	{ "get_tablet_tool_v2", "no", cursor_shape_v1_types + 4 },
},
wp_cursor_shape_device_v1_requests{
	{ "destroy", "", cursor_shape_v1_types + 0 },
	{ "set_shape", "uu", cursor_shape_v1_types + 0 },
},
wp_cursor_shape_manager_v1_interface{
	"wp_cursor_shape_manager_v1", 2,
	3, wp_cursor_shape_manager_v1_requests,
	0, NULL,
},
wp_cursor_shape_device_v1_interface{
	"wp_cursor_shape_device_v1", 2,
	2, wp_cursor_shape_device_v1_requests,
	0, NULL,
} { }

WaylandBuffer::~WaylandBuffer() {
	if (buffer) {
		wayland->wl_buffer_destroy(buffer);
		buffer = nullptr;
	}
}

bool WaylandBuffer::init(WaylandLibrary *lib, wl_shm_pool *pool, int32_t offset, int32_t w,
		int32_t h, int32_t stride, uint32_t format) {
	wayland = lib;
	width = w;
	height = h;
	buffer = wayland->wl_shm_pool_create_buffer(pool, offset, width, height, stride, format);
	return true;
}

KeyState::KeyState() {
	keycodes[KEY_GRAVE] = core::InputKeyCode::GRAVE_ACCENT;
	keycodes[KEY_1] = core::InputKeyCode::_1;
	keycodes[KEY_2] = core::InputKeyCode::_2;
	keycodes[KEY_3] = core::InputKeyCode::_3;
	keycodes[KEY_4] = core::InputKeyCode::_4;
	keycodes[KEY_5] = core::InputKeyCode::_5;
	keycodes[KEY_6] = core::InputKeyCode::_6;
	keycodes[KEY_7] = core::InputKeyCode::_7;
	keycodes[KEY_8] = core::InputKeyCode::_8;
	keycodes[KEY_9] = core::InputKeyCode::_9;
	keycodes[KEY_0] = core::InputKeyCode::_0;
	keycodes[KEY_SPACE] = core::InputKeyCode::SPACE;
	keycodes[KEY_MINUS] = core::InputKeyCode::MINUS;
	keycodes[KEY_EQUAL] = core::InputKeyCode::EQUAL;
	keycodes[KEY_Q] = core::InputKeyCode::Q;
	keycodes[KEY_W] = core::InputKeyCode::W;
	keycodes[KEY_E] = core::InputKeyCode::E;
	keycodes[KEY_R] = core::InputKeyCode::R;
	keycodes[KEY_T] = core::InputKeyCode::T;
	keycodes[KEY_Y] = core::InputKeyCode::Y;
	keycodes[KEY_U] = core::InputKeyCode::U;
	keycodes[KEY_I] = core::InputKeyCode::I;
	keycodes[KEY_O] = core::InputKeyCode::O;
	keycodes[KEY_P] = core::InputKeyCode::P;
	keycodes[KEY_LEFTBRACE] = core::InputKeyCode::LEFT_BRACKET;
	keycodes[KEY_RIGHTBRACE] = core::InputKeyCode::RIGHT_BRACKET;
	keycodes[KEY_A] = core::InputKeyCode::A;
	keycodes[KEY_S] = core::InputKeyCode::S;
	keycodes[KEY_D] = core::InputKeyCode::D;
	keycodes[KEY_F] = core::InputKeyCode::F;
	keycodes[KEY_G] = core::InputKeyCode::G;
	keycodes[KEY_H] = core::InputKeyCode::H;
	keycodes[KEY_J] = core::InputKeyCode::J;
	keycodes[KEY_K] = core::InputKeyCode::K;
	keycodes[KEY_L] = core::InputKeyCode::L;
	keycodes[KEY_SEMICOLON] = core::InputKeyCode::SEMICOLON;
	keycodes[KEY_APOSTROPHE] = core::InputKeyCode::APOSTROPHE;
	keycodes[KEY_Z] = core::InputKeyCode::Z;
	keycodes[KEY_X] = core::InputKeyCode::X;
	keycodes[KEY_C] = core::InputKeyCode::C;
	keycodes[KEY_V] = core::InputKeyCode::V;
	keycodes[KEY_B] = core::InputKeyCode::B;
	keycodes[KEY_N] = core::InputKeyCode::N;
	keycodes[KEY_M] = core::InputKeyCode::M;
	keycodes[KEY_COMMA] = core::InputKeyCode::COMMA;
	keycodes[KEY_DOT] = core::InputKeyCode::PERIOD;
	keycodes[KEY_SLASH] = core::InputKeyCode::SLASH;
	keycodes[KEY_BACKSLASH] = core::InputKeyCode::BACKSLASH;
	keycodes[KEY_ESC] = core::InputKeyCode::ESCAPE;
	keycodes[KEY_TAB] = core::InputKeyCode::TAB;
	keycodes[KEY_LEFTSHIFT] = core::InputKeyCode::LEFT_SHIFT;
	keycodes[KEY_RIGHTSHIFT] = core::InputKeyCode::RIGHT_SHIFT;
	keycodes[KEY_LEFTCTRL] = core::InputKeyCode::LEFT_CONTROL;
	keycodes[KEY_RIGHTCTRL] = core::InputKeyCode::RIGHT_CONTROL;
	keycodes[KEY_LEFTALT] = core::InputKeyCode::LEFT_ALT;
	keycodes[KEY_RIGHTALT] = core::InputKeyCode::RIGHT_ALT;
	keycodes[KEY_LEFTMETA] = core::InputKeyCode::LEFT_SUPER;
	keycodes[KEY_RIGHTMETA] = core::InputKeyCode::RIGHT_SUPER;
	keycodes[KEY_COMPOSE] = core::InputKeyCode::MENU;
	keycodes[KEY_NUMLOCK] = core::InputKeyCode::NUM_LOCK;
	keycodes[KEY_CAPSLOCK] = core::InputKeyCode::CAPS_LOCK;
	keycodes[KEY_PRINT] = core::InputKeyCode::PRINT_SCREEN;
	keycodes[KEY_SCROLLLOCK] = core::InputKeyCode::SCROLL_LOCK;
	keycodes[KEY_PAUSE] = core::InputKeyCode::PAUSE;
	keycodes[KEY_DELETE] = core::InputKeyCode::DELETE;
	keycodes[KEY_BACKSPACE] = core::InputKeyCode::BACKSPACE;
	keycodes[KEY_ENTER] = core::InputKeyCode::ENTER;
	keycodes[KEY_HOME] = core::InputKeyCode::HOME;
	keycodes[KEY_END] = core::InputKeyCode::END;
	keycodes[KEY_PAGEUP] = core::InputKeyCode::PAGE_UP;
	keycodes[KEY_PAGEDOWN] = core::InputKeyCode::PAGE_DOWN;
	keycodes[KEY_INSERT] = core::InputKeyCode::INSERT;
	keycodes[KEY_LEFT] = core::InputKeyCode::LEFT;
	keycodes[KEY_RIGHT] = core::InputKeyCode::RIGHT;
	keycodes[KEY_DOWN] = core::InputKeyCode::DOWN;
	keycodes[KEY_UP] = core::InputKeyCode::UP;
	keycodes[KEY_F1] = core::InputKeyCode::F1;
	keycodes[KEY_F2] = core::InputKeyCode::F2;
	keycodes[KEY_F3] = core::InputKeyCode::F3;
	keycodes[KEY_F4] = core::InputKeyCode::F4;
	keycodes[KEY_F5] = core::InputKeyCode::F5;
	keycodes[KEY_F6] = core::InputKeyCode::F6;
	keycodes[KEY_F7] = core::InputKeyCode::F7;
	keycodes[KEY_F8] = core::InputKeyCode::F8;
	keycodes[KEY_F9] = core::InputKeyCode::F9;
	keycodes[KEY_F10] = core::InputKeyCode::F10;
	keycodes[KEY_F11] = core::InputKeyCode::F11;
	keycodes[KEY_F12] = core::InputKeyCode::F12;
	keycodes[KEY_F13] = core::InputKeyCode::F13;
	keycodes[KEY_F14] = core::InputKeyCode::F14;
	keycodes[KEY_F15] = core::InputKeyCode::F15;
	keycodes[KEY_F16] = core::InputKeyCode::F16;
	keycodes[KEY_F17] = core::InputKeyCode::F17;
	keycodes[KEY_F18] = core::InputKeyCode::F18;
	keycodes[KEY_F19] = core::InputKeyCode::F19;
	keycodes[KEY_F20] = core::InputKeyCode::F20;
	keycodes[KEY_F21] = core::InputKeyCode::F21;
	keycodes[KEY_F22] = core::InputKeyCode::F22;
	keycodes[KEY_F23] = core::InputKeyCode::F23;
	keycodes[KEY_F24] = core::InputKeyCode::F24;
	keycodes[KEY_KPSLASH] = core::InputKeyCode::KP_DIVIDE;
	keycodes[KEY_KPASTERISK] = core::InputKeyCode::KP_MULTIPLY;
	keycodes[KEY_KPMINUS] = core::InputKeyCode::KP_SUBTRACT;
	keycodes[KEY_KPPLUS] = core::InputKeyCode::KP_ADD;
	keycodes[KEY_KP0] = core::InputKeyCode::KP_0;
	keycodes[KEY_KP1] = core::InputKeyCode::KP_1;
	keycodes[KEY_KP2] = core::InputKeyCode::KP_2;
	keycodes[KEY_KP3] = core::InputKeyCode::KP_3;
	keycodes[KEY_KP4] = core::InputKeyCode::KP_4;
	keycodes[KEY_KP5] = core::InputKeyCode::KP_5;
	keycodes[KEY_KP6] = core::InputKeyCode::KP_6;
	keycodes[KEY_KP7] = core::InputKeyCode::KP_7;
	keycodes[KEY_KP8] = core::InputKeyCode::KP_8;
	keycodes[KEY_KP9] = core::InputKeyCode::KP_9;
	keycodes[KEY_KPDOT] = core::InputKeyCode::KP_DECIMAL;
	keycodes[KEY_KPEQUAL] = core::InputKeyCode::KP_EQUAL;
	keycodes[KEY_KPENTER] = core::InputKeyCode::KP_ENTER;
	keycodes[KEY_102ND] = core::InputKeyCode::WORLD_2;
}

static int createAnonymousFile(off_t size) {
	static const char tpl[] = "/xl-wayland-XXXXXX";
	const char *path;
	int fd;
	int ret;

	fd = ::memfd_create("xl-wayland", MFD_CLOEXEC | MFD_ALLOW_SEALING);
	if (fd >= 0) {
		::fcntl(fd, F_ADD_SEALS, F_SEAL_SHRINK | F_SEAL_SEAL);
	} else {
		path = getenv("XDG_RUNTIME_DIR");
		if (!path) {
			errno = ENOENT;
			return -1;
		}

		char *tmpname = (char *)::calloc(strlen(path) + sizeof(tpl), 1);
		::strcpy(tmpname, path);
		::strcat(tmpname, tpl);

		fd = ::mkostemp(tmpname, O_CLOEXEC);
		if (fd >= 0) {
			::unlink(tmpname);
			::free(tmpname);
		} else {
			::free(tmpname);
			return -1;
		}
	}

	ret = ::posix_fallocate(fd, 0, size);
	if (ret != 0) {
		::close(fd);
		errno = ret;
		return -1;
	}
	return fd;
}

static void makeGaussianVector(Color4B *retA, Color4B *retB, uint32_t size) {
	const float sigma = sqrtf((size * size) / (-2.0f * logf(1.0f / 255.0f)));
	const float sigma_v = -1.0f / (2.0f * sigma * sigma);

	for (uint32_t j = 0; j < size; j++) {
		retA[j].a = (uint8_t)(24.0f * expf((j * j) * sigma_v));
		retB[j].a = (uint8_t)(64.0f * expf((j * j) * sigma_v));
	}
}

static void makeGaussianRange(Color4B *retA, Color4B *retB, uint32_t size, uint32_t inset) {
	auto width = size + inset;
	auto targetA = retA;
	auto targetB = retA + width * width;
	auto targetC = retA + width * width * 2;
	auto targetD = retA + width * width * 3;
	auto targetE = retB;
	auto targetF = retB + width * width;
	auto targetG = retB + width * width * 2;
	auto targetH = retB + width * width * 3;

	const float sigma = sqrtf((size * size) / (-2.0f * logf(1.0f / 255.0f)));
	const float sigma_v = -1.0f / (2.0f * sigma * sigma);

	for (uint32_t i = 0; i < width; i++) {
		for (uint32_t j = 0; j < width; j++) {
			float dist = sqrtf((i * i) + (j * j));
			float tmp = 0.0f;
			if (dist <= inset) {
				tmp = 1.0f;
			} else if (dist > size + inset) {
				tmp = 0.0f;
			} else {
				dist = dist - inset;
				tmp = expf((dist * dist) * sigma_v);
			}

			auto valueA = (uint8_t)(24.0f * tmp);
			auto valueB = (uint8_t)(64.0f * tmp);
			targetA[i * width + j].a = valueA;
			targetB[(width - i - 1) * width + (width - j - 1)].a = valueA;
			targetC[(i)*width + (width - j - 1)].a = valueA;
			targetD[(width - i - 1) * width + (j)].a = valueA;
			targetE[i * width + j].a = valueB;
			targetF[(width - i - 1) * width + (width - j - 1)].a = valueB;
			targetG[(i)*width + (width - j - 1)].a = valueB;
			targetH[(width - i - 1) * width + (j)].a = valueB;
		}
	}
}

static void makeRoundedHeader(Color4B *retA, uint32_t size, const Color3B &colorA,
		const Color3B &colorB) {
	auto targetA = retA;
	auto targetB = retA + size * size * 1;
	auto targetC = retA + size * size * 2;
	auto targetD = retA + size * size * 3;

	Color4B tmpA = Color4B(colorA.b, colorA.g, colorA.r, 255);
	Color4B tmpB = Color4B(colorB.b, colorB.g, colorB.r, 255);
	for (uint32_t i = 0; i < size; i++) {
		for (uint32_t j = 0; j < size; j++) {
			auto u = size - i - 1;
			auto v = size - j - 1;
			float dist = sqrtf((u * u) + (v * v));
			if (dist >= size) {
				targetA[i * size + j] = Color4B(0, 0, 0, 0);
				targetB[i * size + j] = Color4B(0, 0, 0, 0);
				targetC[i * size + (size - j - 1)] = Color4B(0, 0, 0, 0);
				targetD[i * size + (size - j - 1)] = Color4B(0, 0, 0, 0);
			} else {
				targetA[i * size + j] = tmpA;
				targetB[i * size + j] = tmpB;
				targetC[i * size + (size - j - 1)] = tmpA;
				targetD[i * size + (size - j - 1)] = tmpB;
			}
		}
	}
}

bool allocateDecorations(WaylandLibrary *wayland, wl_shm *shm, DecorationInfo &info) {
	auto size = info.width * sizeof(Color4B) * 8; // plain shadows
	size += (info.width + info.inset) * (info.width + info.inset) * sizeof(Color4B)
			* 8; // cornerShadows
	size += (info.inset * info.inset) * sizeof(Color4B) * 8; // header corners
	size += 4 * sizeof(Color4B); // header titles

	struct IconData {
		WaylandDecorationName name;
		Value value;
		bool active;
		uint32_t width = 0;
		uint32_t height = 0;
		BytesView data;
	};

	Vector<IconData> icons;

	auto loadData = [&](WaylandDecorationName name, BytesView data, bool active) {
		auto &icon = icons.emplace_back(IconData{name, data::read<Interface>(data), active});
		icon.width = icon.value.getInteger("width");
		icon.height = icon.value.getInteger("height");
		icon.data = icon.value.getBytes("data");
		return icon.width * icon.height * sizeof(Color4B);
	};

	size += loadData(WaylandDecorationName::IconClose, BytesView(s_iconClose, sizeof(s_iconClose)),
			false);
	size += loadData(WaylandDecorationName::IconMaximize,
			BytesView(s_iconMaximize, sizeof(s_iconMaximize)), false);
	size += loadData(WaylandDecorationName::IconMinimize,
			BytesView(s_iconMinimize, sizeof(s_iconMinimize)), false);
	size += loadData(WaylandDecorationName::IconRestore,
			BytesView(s_iconRestore, sizeof(s_iconRestore)), false);
	size += loadData(WaylandDecorationName::IconClose,
			BytesView(s_iconCloseActive, sizeof(s_iconCloseActive)), true);
	size += loadData(WaylandDecorationName::IconMaximize,
			BytesView(s_iconMaximizeActive, sizeof(s_iconMaximizeActive)), true);
	size += loadData(WaylandDecorationName::IconMinimize,
			BytesView(s_iconMinimizeActive, sizeof(s_iconMinimizeActive)), true);
	size += loadData(WaylandDecorationName::IconRestore,
			BytesView(s_iconRestoreActive, sizeof(s_iconRestoreActive)), true);

	const int fd = createAnonymousFile(size);
	if (fd < 0) {
		return false;
	}

	auto data = ::mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (data == MAP_FAILED) {
		::close(fd);
		return false;
	}

	auto pool = wayland->wl_shm_create_pool(shm, fd, size);
	::close(fd);

	auto targetA = (Color4B *)data;
	auto targetB = (Color4B *)data + info.width * 4;
	makeGaussianVector(targetA, targetB, info.width);

	// make normal
	::memcpy(targetA + info.width * 2, targetA, info.width * sizeof(Color4B));
	::memcpy(targetA + info.width * 3, targetA, info.width * sizeof(Color4B));
	std::reverse(targetA, targetA + info.width);
	::memcpy(targetA + info.width * 1, targetA, info.width * sizeof(Color4B));

	// make active
	::memcpy(targetB + info.width * 2, targetB, info.width * sizeof(Color4B));
	::memcpy(targetB + info.width * 3, targetB, info.width * sizeof(Color4B));
	std::reverse(targetB, targetB + info.width);
	::memcpy(targetB + info.width * 1, targetB, info.width * sizeof(Color4B));

	info.ret->top = Rc<WaylandBuffer>::create(wayland, pool, info.width * sizeof(Color4B) * 0, 1,
			info.width, sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->left = Rc<WaylandBuffer>::create(wayland, pool, info.width * sizeof(Color4B) * 0,
			info.width, 1, info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->bottom = Rc<WaylandBuffer>::create(wayland, pool, info.width * sizeof(Color4B) * 2, 1,
			info.width, sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->right = Rc<WaylandBuffer>::create(wayland, pool, info.width * sizeof(Color4B) * 2,
			info.width, 1, info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->topActive = Rc<WaylandBuffer>::create(wayland, pool, info.width * sizeof(Color4B) * 4,
			1, info.width, sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->leftActive =
			Rc<WaylandBuffer>::create(wayland, pool, info.width * sizeof(Color4B) * 4, info.width,
					1, info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->bottomActive =
			Rc<WaylandBuffer>::create(wayland, pool, info.width * sizeof(Color4B) * 6, 1,
					info.width, sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->rightActive =
			Rc<WaylandBuffer>::create(wayland, pool, info.width * sizeof(Color4B) * 6, info.width,
					1, info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);

	auto offset = info.width * 8 * sizeof(Color4B);
	targetA = (Color4B *)data + info.width * 8;
	info.width += info.inset;
	targetB = targetA + info.width * info.width * 4;
	makeGaussianRange(targetA, targetB, info.width - info.inset, info.inset);

	info.ret->bottomRight = Rc<WaylandBuffer>::create(wayland, pool, offset, info.width, info.width,
			info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->topLeft = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.width * info.width * sizeof(Color4B), info.width, info.width,
			info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->bottomLeft = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.width * info.width * 2 * sizeof(Color4B), info.width, info.width,
			info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->topRight = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.width * info.width * 3 * sizeof(Color4B), info.width, info.width,
			info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->bottomRightActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.width * info.width * 4 * sizeof(Color4B), info.width, info.width,
			info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->topLeftActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.width * info.width * 5 * sizeof(Color4B), info.width, info.width,
			info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->bottomLeftActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.width * info.width * 6 * sizeof(Color4B), info.width, info.width,
			info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->topRightActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.width * info.width * 7 * sizeof(Color4B), info.width, info.width,
			info.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);

	offset += info.width * info.width * 8 * sizeof(Color4B);
	targetA = (Color4B *)((uint8_t *)data + offset);

	makeRoundedHeader(targetA, info.inset, info.headerLight, info.headerLightActive);

	info.ret->headerLeft = Rc<WaylandBuffer>::create(wayland, pool, offset, info.inset, info.inset,
			info.inset * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->headerLeftActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.inset * info.inset * sizeof(Color4B) * 1, info.inset, info.inset,
			info.inset * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->headerRight = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.inset * info.inset * sizeof(Color4B) * 2, info.inset, info.inset,
			info.inset * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->headerRightActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.inset * info.inset * sizeof(Color4B) * 3, info.inset, info.inset,
			info.inset * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);

	offset += info.inset * info.inset * sizeof(Color4B) * 4;
	targetA = (Color4B *)((uint8_t *)data + offset);

	makeRoundedHeader(targetA, info.inset, info.headerDark, info.headerDarkActive);

	info.ret->headerDarkLeft = Rc<WaylandBuffer>::create(wayland, pool, offset, info.inset,
			info.inset, info.inset * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->headerDarkLeftActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.inset * info.inset * sizeof(Color4B) * 1, info.inset, info.inset,
			info.inset * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->headerDarkRight = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.inset * info.inset * sizeof(Color4B) * 2, info.inset, info.inset,
			info.inset * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->headerDarkRightActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + info.inset * info.inset * sizeof(Color4B) * 3, info.inset, info.inset,
			info.inset * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);

	offset += info.inset * info.inset * sizeof(Color4B) * 4;
	targetA = (Color4B *)((uint8_t *)data + offset);

	targetA[0] = Color4B(info.headerLight.b, info.headerLight.g, info.headerLight.r, 255);
	targetA[1] = Color4B(info.headerLightActive.b, info.headerLightActive.g,
			info.headerLightActive.r, 255);

	info.ret->headerLightCenter = Rc<WaylandBuffer>::create(wayland, pool, offset, 1, 1,
			sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->headerLightCenterActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + sizeof(Color4B), 1, 1, sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);

	offset += 2 * sizeof(Color4B);
	targetA += 2;

	targetA[0] = Color4B(info.headerDark.b, info.headerDark.g, info.headerDark.r, 255);
	targetA[1] =
			Color4B(info.headerDarkActive.b, info.headerDarkActive.g, info.headerDarkActive.r, 255);

	info.ret->headerDarkCenter = Rc<WaylandBuffer>::create(wayland, pool, offset, 1, 1,
			sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
	info.ret->headerDarkCenterActive = Rc<WaylandBuffer>::create(wayland, pool,
			offset + sizeof(Color4B), 1, 1, sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);

	offset += 2 * sizeof(Color4B);
	targetA += 2;

	for (IconData &it : icons) {
		memcpy((uint8_t *)data + offset, it.data.data(), it.data.size());
		Rc<WaylandBuffer> buf = Rc<WaylandBuffer>::create(wayland, pool, offset, it.width,
				it.height, it.width * sizeof(Color4B), WL_SHM_FORMAT_ARGB8888);
		switch (it.name) {
		case WaylandDecorationName::IconClose:
			if (it.active) {
				info.ret->iconCloseActive = move(buf);
			} else {
				info.ret->iconClose = move(buf);
			}
			break;
		case WaylandDecorationName::IconMaximize:
			if (it.active) {
				info.ret->iconMaximizeActive = move(buf);
			} else {
				info.ret->iconMaximize = move(buf);
			}
			break;
		case WaylandDecorationName::IconMinimize:
			if (it.active) {
				info.ret->iconMinimizeActive = move(buf);
			} else {
				info.ret->iconMinimize = move(buf);
			}
			break;
		case WaylandDecorationName::IconRestore:
			if (it.active) {
				info.ret->iconRestoreActive = move(buf);
			} else {
				info.ret->iconRestore = move(buf);
			}
			break;
		default: break;
		}
		offset += it.data.size();
	}

	::munmap(data, size);
	wayland->wl_shm_pool_destroy(pool);

	return true;
}

uint32_t getWaylandCursor(WindowLayerFlags flags) {
	switch (flags & WindowLayerFlags::CursorMask) {
	case WindowLayerFlags::CursorDefault: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DEFAULT; break;
	case WindowLayerFlags::CursorContextMenu:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CONTEXT_MENU;
		break;
	case WindowLayerFlags::CursorHelp: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_HELP; break;
	case WindowLayerFlags::CursorPointer: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_POINTER; break;
	case WindowLayerFlags::CursorProgress: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_PROGRESS; break;
	case WindowLayerFlags::CursorWait: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_WAIT; break;
	case WindowLayerFlags::CursorCell: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CELL; break;
	case WindowLayerFlags::CursorCrosshair: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_CROSSHAIR; break;
	case WindowLayerFlags::CursorText: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_TEXT; break;
	case WindowLayerFlags::CursorVerticalText:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_VERTICAL_TEXT;
		break;
	case WindowLayerFlags::CursorAlias: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALIAS; break;
	case WindowLayerFlags::CursorCopy: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COPY; break;
	case WindowLayerFlags::CursorMove: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_MOVE; break;
	case WindowLayerFlags::CursorNoDrop: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NO_DROP; break;
	case WindowLayerFlags::CursorNotAllowed:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NOT_ALLOWED;
		break;
	case WindowLayerFlags::CursorGrab: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_GRAB; break;
	case WindowLayerFlags::CursorGrabbing: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_GRABBING; break;

	case WindowLayerFlags::CursorAllScroll:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_SCROLL;
		break;
	case WindowLayerFlags::CursorZoomIn: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ZOOM_IN; break;
	case WindowLayerFlags::CursorZoomOut: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ZOOM_OUT; break;
	case WindowLayerFlags::CursorDndAsk: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_DND_ASK; break;

	case WindowLayerFlags::CursorRightPtr: return 0; break;
	case WindowLayerFlags::CursorPencil: return 0; break;
	case WindowLayerFlags::CursorTarget: return 0; break;

	case WindowLayerFlags::CursorResizeRight:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_E_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeTop: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_N_RESIZE; break;
	case WindowLayerFlags::CursorResizeTopRight:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NE_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeTopLeft:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NW_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeBottom:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_S_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeBottomRight:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_SE_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeBottomLeft:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_SW_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeLeft: return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_W_RESIZE; break;
	case WindowLayerFlags::CursorResizeLeftRight:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_EW_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeTopBottom:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NS_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeTopRightBottomLeft:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NESW_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeTopLeftBottomRight:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_NWSE_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeCol:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_COL_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeRow:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ROW_RESIZE;
		break;
	case WindowLayerFlags::CursorResizeAll:
		return WP_CURSOR_SHAPE_DEVICE_V1_SHAPE_ALL_RESIZE;
		break;
	default: return 0; break;
	}
	return 0;
}

std::ostream &operator<<(std::ostream &out, WaylandDecorationName name) {
	switch (name) {
	case WaylandDecorationName::RightSide: out << "RightSide"; break;
	case WaylandDecorationName::TopRightCorner: out << "TopRightCorner"; break;
	case WaylandDecorationName::TopSide: out << "TopSide"; break;
	case WaylandDecorationName::TopLeftCorner: out << "TopLeftCorner"; break;
	case WaylandDecorationName::BottomRightCorner: out << "BottomRightCorner"; break;
	case WaylandDecorationName::BottomSide: out << "BottomSide"; break;
	case WaylandDecorationName::BottomLeftCorner: out << "BottomLeftCorner"; break;
	case WaylandDecorationName::LeftSide: out << "LeftSide"; break;
	case WaylandDecorationName::HeaderLeft: out << "HeaderLeft"; break;
	case WaylandDecorationName::HeaderRight: out << "HeaderRight"; break;
	case WaylandDecorationName::HeaderCenter: out << "HeaderCenter"; break;
	case WaylandDecorationName::HeaderBottom: out << "HeaderBottom"; break;
	case WaylandDecorationName::IconClose: out << "IconClose"; break;
	case WaylandDecorationName::IconMaximize: out << "IconMaximize"; break;
	case WaylandDecorationName::IconMinimize: out << "IconMinimize"; break;
	case WaylandDecorationName::IconRestore: out << "IconRestore"; break;
	}
	return out;
}

} // namespace stappler::xenolith::platform
